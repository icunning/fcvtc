// mainwindow.cpp
//

//#include <QTimer>
#include <QMessageBox>
#include <QTableWidget>
#include <QDateTime>
#include <QScrollBar>
#include <QThread>


#include "mainwindow.h"
#include "ui_mainwindow.h"
#include "ltkcpp.h"
#include "creader.h"


extern double blackLineDistancem;


struct riders_t {
    unsigned long long tagId;
    QString name;
};



MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
{
    ui->setupUi(this);


    // Configure tables

    QTableWidget *t = ui->lapsTableWidget;
    t->setColumnWidth(0, 250);
    t->setColumnWidth(1, 100);
    t->setColumnWidth(2, 150);
    t->setColumnWidth(3, 200);

    t = ui->ridersTableWidget;
    t->setColumnWidth(0, 250);
    t->setColumnWidth(1, 100);
    t->setColumnWidth(2, 150);
    t->setColumnWidth(3, 200);

    try {

        // Open connection to reader, exit on error

        int verbose = 0;
        int readerId = 1;
        QString hostname;// = "192.168.1.98";

        // Move CReader to new thread

        QThread *readerThread = new QThread(this);
        CReader *reader = new CReader;
        reader->connectToReader(hostname, readerId, verbose);
        reader->moveToThread(readerThread);
        connect(readerThread, SIGNAL(started(void)), reader, SLOT(onStarted(void)));
        //connect(reader, SIGNAL(finished()), reader, SLOT(deleteLater()));
        //connect(readerThread, SIGNAL(finished(void)), readerThread, SLOT(deleteLater(void)));
        readerThread->start();


        // Add reader to list of readers

        readerList.append(reader);

        // Make connections to handle signals generated by reader

        for (int i=0; i<readerList.size(); i++) {
//            for (int j=0; j<readerList[i]->getTransmitPowerList()->size(); j++) {
//                printf("INFO: Reader %d Power index %d, power %d\n", i, j, readerList[i]->getTransmitPowerList()->at(j));
//                fflush(stdout);
//            }
            connect(readerList[i], SIGNAL(newTag(CTagInfo)), this, SLOT(onNewTag(CTagInfo)));
            connect(readerList[i], SIGNAL(newLogMessage(QString)), this, SLOT(onNewLogMessage(QString)));
        }

    }
    catch (QString s) {
        QMessageBox::critical(this, "fcvtc", s);
    }
    catch (...) {
        QMessageBox::critical(this, "fcvtc", "Unexpected exception");
    }
}

MainWindow::~MainWindow()
{
    delete ui;
    for (int i=0; i<readerList.size(); i++) {
        delete readerList[i];
    }
    readerList.clear();
}


void MainWindow::onReaderCheckTimeout(void) {
    printf("onReaderCheckTimeout\n");
    fflush(stdout);
    readerCheckTimer.stop();
    for (int i=0; i<readerList.size(); i++) {
        readerList[i]->processReports();//processRecentChipsSeen();
    }
    readerCheckTimer.start();
}


void MainWindow::onNewTag(CTagInfo tagInfo) {
    QString s, s2;
    QTableWidget *t = ui->lapsTableWidget;
    QTextEdit *m = ui->messageConsoleTextEdit;
    static int tableEntryCount = 0;
    static QList<unsigned long long> previousTime;
    static QList<int> previousTagId;
    static int lapCount = 0;

    // Current time (nearest second, used for display only, not timing)

    QString time = QTime::currentTime().toString("hh:mm:ss");

    // Add string to messages window

    s.sprintf("readerId=%d antennaId=%d timeStampUSec=%llu", tagInfo.readerId, tagInfo.antennaId, tagInfo.timeStampUSec);
    for (int i=0; i<tagInfo.data.size(); i++) {
        if (i == 0) s.append(s2.sprintf(" data=%02x", tagInfo.data[i]));
        else s.append(s2.sprintf(" %02x", tagInfo.data[i]));
    }
    s.append(" ");
    s.append(tagInfo.dataText);
    bool scrollToBottomRequired = false;
    if (m->verticalScrollBar()->sliderPosition() == m->verticalScrollBar()->maximum()) {
        scrollToBottomRequired = true;
    }
    m->insertHtml(s + "<br>");
    if (scrollToBottomRequired) {
        m->verticalScrollBar()->setValue(m->verticalScrollBar()->maximum());
    }

    // tagId

    unsigned long long tagId = (unsigned long long)tagInfo.data[0] << 40 | (unsigned long long)tagInfo.data[1] << 32 | (unsigned long long)tagInfo.data[2] << 24 | (unsigned long long)tagInfo.data[3] << 16 | (unsigned long long)tagInfo.data[4] << 8 | (unsigned long long)tagInfo.data[5];

    // Maintain table of active riders.  If name is not in list, get from dBase.

    static QList<riders_t> activeRiders;
    bool newRider = true;
    int riderIndex = 0;
    for (int i=0; i<activeRiders.size(); i++) {
        if (activeRiders[i].tagId == tagId) {
            newRider = false;
            riderIndex = i;
            break;
        }
    }
    QString name;
    if (newRider) {
        switch (tagId & 0x000000ff) {
        case 0:
            name = "Chris";
            break;
        case 1:
            name = "Peter";
            break;
        case 2:
            name = "Sue";
            break;
        case 3:
            name = "Cindy";
            break;
        }

        // If name not found, use tagId

        if (name.isEmpty()) {
            name.sprintf("%2x %02x %02x %02x %02x %02x", tagInfo.data[0], tagInfo.data[1], tagInfo.data[2], tagInfo.data[3], tagInfo.data[4], tagInfo.data[5]);
        }

        // Add to activeRiders

        riders_t newRider;
        newRider.name = name;
        newRider.tagId = tagId;
        activeRiders.append(newRider);

        // If necessary, increase size of riders table to accomodate new entry

        t = ui->ridersTableWidget;
        bool scrollToBottomRequired = false;
        if (t->verticalScrollBar()->sliderPosition() == t->verticalScrollBar()->maximum()) {
            scrollToBottomRequired = true;
        }
        int r = t->rowCount();
        t->insertRow(r);
        t->setRowHeight(r, 24);
        if (scrollToBottomRequired) {
            t->scrollToBottom();
        }

        t->setSortingEnabled(false);
        t->setItem(r, 0, new QTableWidgetItem());
        t->item(r, 0)->setText(name);
        t->setItem(r, 1, new QTableWidgetItem());
//        t->item(r, 1)->setText(time);
//        if (lapSec > 0.) {
        //        QTableWidgetItem *item;
//                    item = new QTableWidgetItem();
//                    item->setData(Qt::EditRole, lapSec);
//                    t->setItem(r, 2, item);
//                    item = new QTableWidgetItem();
//                    item->setData(Qt::EditRole, lapSpeed);
//                    t->setItem(r, 3, item);
//                }

        // Re-enable sorting only is table is not really large

        if (t->rowCount() < 50) {
            t->setSortingEnabled(true);
        }

    }
    else {
        name = activeRiders[riderIndex].name;
    }



    // Check to see if this tag is in previousTagId.  If it is, compute lap time.
    // If lap time is greater than some min value, assume this is first crossing after a rest so no lap time.
    // If not in list, assume first crossing so add to list but no lap time.

    double lapSec = 0.;
    int index = previousTagId.indexOf(tagId);
    if (index >= 0) {
        lapSec = tagInfo.timeStampUSec - previousTime[index];
        previousTime[index] = tagInfo.timeStampUSec;
    }
    else {
        previousTagId.append(tagId);
        previousTime.append(tagInfo.timeStampUSec);
        lapSec = 0.;
    }

    // If lap time is greater than 120 sec, rider must have taken a break so do not
    // calculate lap time

    double maxLapSec = 120.;
    if (lapSec > maxLapSec) lapSec = 0.;

    // Lap speed around black line

    double lapSpeed = 0.;
    if (lapSec > 0.) {
        lapSpeed = blackLineDistancem / (lapSec / 3600.) / 1000.;
    }


    // If necessary, increase size of table to accomodate new entry

    t = ui->lapsTableWidget;
    int r = tableEntryCount;
    if (tableEntryCount >= t->rowCount()) {
        for (int i=0; i<1; i++) {
            bool scrollToBottomRequired = false;
            if (t->verticalScrollBar()->sliderPosition() == t->verticalScrollBar()->maximum()) {
                scrollToBottomRequired = true;
            }
            t->insertRow(tableEntryCount + i);
            t->setRowHeight(r, 24);
            if (scrollToBottomRequired) {
                t->scrollToBottom();
            }
        }
    }

    // Add new entry to bottom of table

    t = ui->lapsTableWidget;
    t->setSortingEnabled(false);
    QTableWidgetItem *item;
    t->setItem(r, 0, new QTableWidgetItem());
    t->item(r, 0)->setText(name);
    t->setItem(r, 1, new QTableWidgetItem());
    t->item(r, 1)->setText(time);
    if (lapSec > 0.) {
        item = new QTableWidgetItem();
        item->setData(Qt::EditRole, lapSec);
        t->setItem(r, 2, item);
        item = new QTableWidgetItem();
        item->setData(Qt::EditRole, lapSpeed);
        t->setItem(r, 3, item);
    }

    // Re-enable sorting only if table is not really large

    if (t->rowCount() < 10000) {
        t->setSortingEnabled(true);
    }

    tableEntryCount++;

    // lapCount is total laps all riders

    lapCount++;
    ui->lapCountLineEdit->setText(s.setNum(lapCount));

    ui->riderCountLineEdit->setText(s.setNum(activeRiders.size()));

}


void MainWindow::onNewLogMessage(QString s) {
    QTextEdit *m = ui->messageConsoleTextEdit;
    //printf("message: %s\n", s.toLatin1().data());
    //fflush(stdout);
    bool scrollToBottomRequired = false;
    if (m->verticalScrollBar()->sliderPosition() == m->verticalScrollBar()->maximum()) {
        scrollToBottomRequired = true;
    }
    m->insertHtml(s + "<br>");
    if (scrollToBottomRequired) {
        m->verticalScrollBar()->setValue(m->verticalScrollBar()->maximum());
    }
}
